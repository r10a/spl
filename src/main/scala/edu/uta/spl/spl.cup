/********************************************************************************
*
* File: spl.cup
* The SPL parser
*
********************************************************************************/

package edu.uta.spl;

import scala.collection.immutable.*;
import scala.Tuple2;
import java_cup.runtime.*;


parser code {:

    static int[] tokens = {
      sym.error, sym.ID, sym.STRING_LITERAL, sym.INTEGER_LITERAL, sym.FLOAT_LITERAL,
      sym.AND, sym.ARRAY, sym.BOOLEAN, sym.BY, sym.DEF, sym.DIV, sym.ELSE, sym.EQUAL, sym.EXIT, sym.FALSE,
      sym.FLOAT, sym.FOR, sym.IF, sym.INT, sym.LOOP, sym.MOD,
      sym.NOT, sym.OR, sym.PRINT, sym.READ, sym.RETURN, sym.STRING, sym.TO, sym.TYPE, sym.VAR, sym.WHILE,
      sym.PLUS, sym.MINUS, sym.TIMES, sym.TRUE,
      sym.LT, sym.LEQ, sym.GT, sym.GEQ, sym.EQ, sym.NEQ, sym.COLON, sym.SEMI,
      sym.COMMA, sym.SHARP, sym.DOT, sym.LP, sym.RP, sym.LB, sym.RB, sym.LSB, sym.RSB
    };

    static String[] token_names = {
      "error", "ID", "STRING_LITERAL", "INTEGER_LITERAL", "FLOAT_LITERAL",
      "AND &&", "ARRAY", "BOOLEAN", "BY", "DEF", "DIV /", "ELSE", "EQUAL", "EXIT", "FALSE",
      "FLOAT", "FOR", "IF", "INT", "LOOP", "MOD %",
      "NOT", "OR ||", "PRINT", "READ", "RETURN", "STRING", "TO", "TYPE", "VAR", "WHILE",
      "PLUS +", "MINUS -", "TIMES *", "TRUE",
      "LT <", "LEQ <=", "GT >", "GEQ >=", "EQ ==", "NEQ <>", "COLON :", "SEMI ;",
      "COMMA ,", "SHARP #", "DOT .", "LP (", "RP )", "LB "+'{', "RB "+'}', "LSB [", "RSB ]"
    };

    public static String print ( Symbol s ) {
        for ( int i = 0; i < tokens.length; i++ ) {
            if (tokens[i] == s.sym) {
                String res = token_names[i] + " ";
                if (s.value == null)
                    return res;
                else if (s.value instanceof Integer)
                    return res + ((Integer) s.value).intValue();
                else if (s.value instanceof Float)
                    return res + ((Float) s.value).floatValue();
                else if (s.value instanceof String)
                    return res + "\"" + (String) s.value + "\"";
            }
        };
        return "?";
    }

    public void syntax_error ( Symbol token ) {
        System.err.println("*** Syntax Error: " + print(token) + " (line: " + token.left
                           + ", column: " + token.right + ")");
        System.exit(1);
    }

    /** nil is the empty list */
    final static List nil = Nil$.MODULE$;

    /** Append list2 at the end of list1 (ie, return a new list containing
        the elements from list1 followed by the elements from list2) */
    static<T> List<T> append ( List<T> list1, List<T> list2 ) {
        return list1.$colon$colon$colon(list2);
    }

    /** append the element elem at the end of the list
       (ie, return a new list containing the list followed by the elem) */
    static<T> List<T> append ( List<T> list, T elem ) {
        return nil.$colon$colon(elem).$colon$colon$colon(list);
    }

    /** Insert the element elem at the beginning of the list
        (ie, return a new list containing the elem followed by the list) */
    static<T> List<T> add ( T elem, List<T> list ) {
        return list.$colon$colon(elem);
    }

:};

/* Terminals (tokens returned by the scanner). */
terminal String  ID, STRING_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal Float 	 FLOAT_LITERAL;
terminal         AND, ARRAY, BOOLEAN, BY, DEF, DIV, ELSE, EQUAL, EXIT, FALSE,
                 FLOAT, FOR, IF, INT, LOOP, MOD,
                 NOT, OR, PRINT, READ, RETURN, STRING, TO, TYPE, VAR, WHILE, UMINUS,
                 PLUS, MINUS, TIMES, TRUE, LT, LEQ, GT, GEQ, EQ, NEQ, COLON, SEMI,
                 COMMA, SHARP, DOT, LP, RP, LB, RB, LSB, RSB;

non terminal program;
non terminal block_content;
non terminal def;
non terminal defs;
non terminal params;
non terminal type;
non terminal returntype;
non terminal lvalue;
non terminal lvaluelist;
non terminal expr;
non terminal exprlist;
non terminal unaryOp;
non terminal binaryOp;
non terminal stmt;
non terminal stmts;
non terminal bystat;

precedence nonassoc	ELSE;
precedence right EQUAL;
precedence right AND, OR, DOT;
precedence left	LT, GT, LEQ, GEQ, NEQ, EQ;

precedence left	PLUS, MINUS;
precedence left	TIMES, DIV, MOD;

precedence left UMINUS, NOT;

start with program;

program         ::= block_content                  
                ;
block_content   ::= defs stmts
				| stmts                
                ;
defs            ::= defs def SEMI
				| def SEMI
				;           
def				::= VAR ID EQUAL expr
				| VAR ID COLON type EQUAL expr
				| TYPE ID EQUAL type
				| DEF ID LP params RP returntype LB block_content RB 
				;
params			::= ID COLON type COMMA params
				| ID COLON type
				| type COMMA params
				| type
				|
				;
returntype		::= COLON type
				|
				;
type			::= INT 
				| FLOAT
				| STRING
				| BOOLEAN
				| ID
				| ARRAY LSB type RSB
				| LB params RB
				| LP params RP
				;
lvalue			::= ID
				| lvalue LSB expr RSB
				| lvalue DOT ID
				| lvalue SHARP INTEGER_LITERAL
				;				                
expr            ::= INTEGER_LITERAL
				| FLOAT_LITERAL
				| STRING_LITERAL
				| TRUE
				| FALSE
				| lvalue
				| unaryOp expr
				| expr binaryOp expr
				| ARRAY LP expr COMMA expr RP
				| ID LP exprlist RP 
				| LB ID EQUAL exprlist RB
				| LP exprlist RP
				| LSB exprlist RSB
                ;
exprlist		::= expr COMMA exprlist
				| expr COMMA ID EQUAL exprlist
				| expr
				|
				;
lvaluelist		::= lvalue COMMA lvaluelist
				| lvalue
				;
unaryOp 		::=  MINUS 
				| NOT
				;
binaryOp		::= PLUS
				| MINUS
				| TIMES
				| DIV
				| MOD
				| AND
				| OR
				| EQ
				| NEQ
				| LT
				| LEQ
				| GT
				| GEQ
				;	
stmts           ::= stmts stmt SEMI
                | stmt SEMI
                ;							
stmt            ::= lvalue EQUAL expr
				| ID LP exprlist RP
				| LB block_content RB
				| READ LP lvaluelist RP
				| PRINT LP exprlist RP
				| IF LP expr RP stmt
				| IF LP expr RP stmt ELSE stmt
				| FOR LP ID EQUAL expr TO expr bystat RP stmt
				| WHILE LP expr RP stmt
				| LOOP stmt
				| EXIT
				| RETURN exprlist
				;
bystat			::= BY expr
				| 
				;